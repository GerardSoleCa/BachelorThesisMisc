\chapter{State of the art}\label{C:State-Art}

This chapter sketches out briefly the state of the art of the embedded operating systems and its capabilities. Then according to this thesis will be explained what is the current operating system running on the bottom of HomeSense and finally why has been chosen the RaspberryPi as the target device of this thesis.

\section{Embedded Systems}\label{S:Embedded-Systems}
Embedded Systems now a days are taking relevance again with the Internet of the Things, environment sensing, Wireless Sensor Networks and all the coming technologies that require low power consumption, small size, mobility environments etc.

In Embedded Systems or Resource Constrained System it's interesting to take a look into the Hardware platform and its capabilities, and nowadays it 


An operating system (OS) offers an interface with the hardware to make it independent from the applications that the device runs, making easy the interactions between hardware or other running programs.

An OS is an important program that makes easy to develop applications, but it is important to maintain the features that the processor offers, avoiding performance or capabilities degradation. As this bachelor thesis is focused on constrained-resource devices, where the processing capabilities and memory resources are limited, is fundamental to respect the above criteria.

In general, there are three types of operating system architectures based on how applications are executed:

\begin{itemize}
\item \textbf{Monolithic:} The OS and the applications are combined in a single program, being an end to end task without the possibility to include new functions without rewriting much of the code.

\item \textbf{Modular:} The OS is running as a standalone program in the processor and has de ability to load programs to it self as modules. In terms of the development, it's possible to develop applications without writing in the core of the OS.

\item \textbf{Virtual-Machine:} The OS creates an abstraction layer of its underlying hardware, this abstracted layer is common in every device that implements that virtual-machine. Using this type of operating system provides a helpful tool to achieve the well known slogan \textit{write once, run anywhere}. 
\end{itemize}


\begin{itemize}
\item \textbf{TinyOS:} asdf asdf asdf.

\item \textbf{FreeRTOS:} asdf asdf asdf.

\item \textbf{uC/OS II:} asdf asdf asdf.

\item \textbf{Contiki:} asdf asdf asdf.

\item \textbf{Micro Framework .NET:} asdf asdf asdf.
\end{itemize}



\section{Micro Framework .NET}\label{S:MicroFramework}

Complexity and heterogeneity drawbacks of distributed systems could be solved or relived using a middleware. Middleware is a system software that resides between the applications and the underlying operating systems, network protocol stacks, and hardware, which provides facilities in order to build and use distributed systems \cite{cite:middleware}.

This type of software provides a transparent and abstract vision of the low-level details (e.g. network communication, encoding, concurrency, protocol handling, etc.) facilitating end user programming. Middlweware typically provides two different types of transparency to distributed systems:

\begin{itemize}
\item \textbf{Access transparency:} Hides differences between remote and local operations like data representation and invocation mechanisms.

\item \textbf{Location transparency:} Hides where the components reside. The  different components could be 
redistributed (e.g. moved between computers) without changing any of the other components.
\end{itemize}

\subsection{NETMF enabled devices}\label{SS:MicroFramework-Devices}

MicroFramework can run on CLR enabled devices that are MicroFramework compilant with it's specifications. In this bachelor thesis a Netduino Plus (from XXXXXLabs) has been used to test, understand and code sample code in order to know how Microframework works. Apart from this Netduino there are other devices like the cerbuino,which are also capable to run CLR code.

Among this, there are more powerful devices that can run and execute simple graphics programs.


\subsection{Software Development Kit}\label{SS:MicroFramework-SDK}
As Micro Framework is similar to an operating system it has

\begin{itemize}
\item \textbf{4.3:} This asynchronous indirect communication model uses a queue in order to exchange messages. The messages from the producer are stored into the consumer's queue after being sent. In this type of model, persistent queues are used when the reliability is required in front of performance. Quality of service (QoS) policies are also a good solution to provide reliability.

\item \textbf{4.2:} In this direct communication model, the messages are sent directly to the interested parts through publish/subscribe pattern. In this pattern, the different parts register interest in receiving messages on a particular message topic. After the subscription, the consumer will receive any message corresponding to the subscribed topic.

\end{itemize}

BlaBlaBla both blablabla

\subsection{Visual Studio}\label{SS:MicroFramework-IDE}

\section{RaspberryPi and MicroFramework}\label{S:RaspberryPi-NETMF}
Before starting with the development a search was done in order to know if there was any project involving the port of the MicroFramework to Linux devices using, for example, Mono. Nothing was found.
There is currently one implementation of MicroFramework for Linux, but it only works in a resource-constrained device called Edy Linux.

RaspberryPi has many implementations in different languages involving its IO ports, many are written in C and Python, others are for example in Java. But when speaking in terms of .NET/C\# there is an important lack in IO implementations, below are exposed the most important ones that where found.

\begin{itemize}
\item \textbf{BlaBlaBla:}
\item \textbf{BlaBlaBla:}
\end{itemize}

Although the XXX library is really interesting according to it's description of functionality, it doesn't 